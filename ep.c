#include "compat/conio.h"
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/un.h>

#define EP_TERMSPEC "unix socket terminal"
#define SERVER_SOCK_FILE "comm"

/* SLIP special character codes
 */
#define END 0300     /* indicates end of packet */
#define ESC 0333     /* indicates byte stuffing */
#define ESC_END 0334 /* ESC ESC_END means END data byte */
#define ESC_ESC 0335 /* ESC ESC_ESC means ESC data byte */

int fd;

void send_char(unsigned char c) {
  if (send(fd, &c, 1, 0) == -1) {
    perror("send");
    close(fd);
    exit(1);
  }
}

unsigned char recv_char() {
  unsigned char c = 0;
  if (recv(fd, &c, 1, 0) < 0) {
    perror("recv");
    close(fd);
    exit(1);
  }
  return c;
}

/* SEND_PACKET: sends a packet of length "len", starting at
 * location "p".
 */
void send_packet(unsigned char *p, int len) {

  /* send an initial END character to flush out any data that may
   * have accumulated in the receiver due to line noise
   */
  send_char(END);

  /* for each byte in the packet, send the appropriate character
   * sequence
   */
  while (len--) {
    switch (*p) {
    /* if it's the same code as an END character, we send a
     * special two character code so as not to make the
     * receiver think we sent an END
     */
    case END:
      send_char(ESC);
      send_char(ESC_END);
      break;

    /* if it's the same code as an ESC character,
     * we send a special two character code so as not
     * to make the receiver think we sent an ESC
     */
    case ESC:
      send_char(ESC);
      send_char(ESC_ESC);
      break;

    default:
      send_char(*p);
    }

    p++;
  }

  /* tell the receiver that we're done sending the packet
   */
  send_char(END);
}

/* RECV_PACKET: receives a packet into the buffer located at "p".
 *      If more than len bytes are received, the packet will
 *      be truncated.
 *      Returns the number of bytes stored in the buffer.
 */
int recv_packet(unsigned char *p, int len) {
  unsigned char c;
  int received = 0;

  /* sit in a loop reading bytes until we put together
   * a whole packet.
   * Make sure not to copy them into the packet if we
   * run out of room.
   */
  while (1) {
    /* get a character to process
     */
    c = recv_char();

    /* handle bytestuffing if necessary
     */
    switch (c) {

    /* if it's an END character then we're done with
     * the packet
     */
    case END:
      /* a minor optimization: if there is no
       * data in the packet, ignore it. This is
       * meant to avoid bothering IP with all
       * the empty packets generated by the
       * duplicate END characters which are in




       * turn sent to try to detect line noise.
       */
      if (received)
        return received;
      else
        break;

    /* if it's the same code as an ESC character, wait
     * and get another character and then figure out
     * what to store in the packet based on that.
     */
    case ESC:
      c = recv_char();

      /* if "c" is not one of these two, then we
       * have a protocol violation.  The best bet
       * seems to be to leave the byte alone and
       * just stuff it into the packet
       */
      switch (c) {
      case ESC_END:
        c = END;
        break;
      case ESC_ESC:
        c = ESC;
        break;
      }

    /* here we fall into the default handler and let
     * it store the character for us
     */
    default:
      if (received < len)
        p[received++] = c;
    }
  }
}

int main() {
  struct sockaddr_un addr;
  unsigned char buff[8192];
  unsigned char *p;
  int l, i;

  if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
    perror("socket");
    return 1;
  }

  memset(&addr, 0, sizeof(addr));
  addr.sun_family = AF_UNIX;
  strcpy(addr.sun_path, SERVER_SOCK_FILE);
  if (connect(fd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
    perror("connect");
    return 1;
  }

  while (1) {
    memset(buff, 0, sizeof(buff));
    l = recv_packet(buff, sizeof(buff));
    if (l == 0)
      continue;
    if (buff[0] == 0x00 && buff[1] == 0x00) {
      p = buff;
      *(p++);
      *(p++);
      strncpy((char *)p, EP_TERMSPEC, sizeof(EP_TERMSPEC));
      send_packet(buff, 2 + sizeof(EP_TERMSPEC));
    }
    if (buff[0] == 0x01 && buff[1] == 0x01) {
      if (kbhit()) {
        buff[2] = getch();
        send_packet(buff, 3);
      } else {
        send_packet(buff, 2);
      }
    }
    if (buff[0] == 0x02 && buff[1] == 0x02) {
      p = buff;
      *(p++);
      *(p++);
      printf("%s", (char *)p);
      send_packet(buff, 2);
    }
    // deprecated
    if (buff[0] == 0x0f && buff[1] == 0x0f) {
      gotoxy(0, 0);
      for (i = 2; i < l; i++)
        printf("%c", buff[i]);
      send_packet(buff, 2);
    }
  }

  close(fd);
  return 0;
}
